#include "SourceControl.h"

#include <stdlib.h>
#include <stdio.h>
#include <Catalog.h>
#include <Locale.h>

#include "../DebugTools.h"
#include "../Globals.h"


#undef B_TRANSLATION_CONTEXT
#define B_TRANSLATION_CONTEXT "SourceControl"

SourceControl::SourceControl(void)
  :	fFlags(0),
  	fDebug(false),
	fCallback(NULL)
{
}


SourceControl::SourceControl(const entry_ref &workingDir)
  :	fFlags(0),
  	fDebug(false),
  	fCallback(NULL)
{
	SetWorkingDirectory(workingDir);
}


SourceControl::~SourceControl(void)
{
}


const char *
SourceControl::GetShortName(void) const
{
	return fShortName.String();
}


const char *
SourceControl::GetLongName(void) const
{
	return fLongName.String();
}


int32
SourceControl::GetFlags(void) const
{
	return fFlags;
}


status_t
SourceControl::SetWorkingDirectory(const entry_ref &topDir)
{
	BPath path(&topDir);
	if (path.InitCheck() != B_OK)
		return path.InitCheck();
	
	fWorkingDir = path.Path();
	return B_OK;
}


status_t
SourceControl::SetWorkingDirectory(const char *path)
{
	fWorkingDir = path;
	return B_OK;
}


const char *
SourceControl::GetWorkingDirectory(void) const
{
	return fWorkingDir.String();
}


void
SourceControl::SetUsername(const char *username)
{
	fUsername = username;
}


bool
SourceControl::NeedsInit(const char *topDir)
{
	return false;
}


status_t
SourceControl::CreateRepository(const char *path)
{
	return B_OK;
}


bool
SourceControl::DetectRepository(const char *path)
{
	return false;
}


status_t
SourceControl::CloneRepository(const char *url, const char *dest)
{
	return B_OK;
}


status_t
SourceControl::AddToRepository(const char *path)
{
	return B_OK;
}


status_t
SourceControl::RemoveFromRepository(const char *path)
{
	return B_OK;
}


status_t
SourceControl::Commit(const char *msg)
{
	return B_OK;
}


status_t
SourceControl::Merge(const char *rev)
{
	return B_OK;
}


status_t
SourceControl::Push(const char *url)
{
	return B_OK;
}


status_t
SourceControl::Pull(const char *url)
{
	return B_OK;
}


status_t
SourceControl::Revert(const char *relPath)
{
	return B_OK;
}


status_t
SourceControl::Rename(const char *oldname, const char *newname)
{
	return B_OK;
}


status_t
SourceControl::Diff(const char *file, const char *revision)
{
	return B_OK;
}


status_t
SourceControl::GetHistory(BString &out, const char *file)
{
	return B_OK;
}


status_t
SourceControl::GetChangeStatus(BString &out)
{
	return B_OK;
}


status_t
SourceControl::GetCheckinHeader(BString &out)
{
	return B_OK;
}


void
SourceControl::SetURL(const char *url)
{
	fURL = url;
}


BString	
SourceControl::GetURL(void) const
{
	return fURL;
}


void
SourceControl::SetDebugMode(bool value)
{
	fDebug = value;
}


bool
SourceControl::GetDebugMode(void) const
{
	return fDebug;
}


void
SourceControl::SetVerboseMode(bool value)
{
	fVerbose = value;
}


bool
SourceControl::GetVerboseMode(void) const
{
	return fVerbose;
}


void
SourceControl::SetUpdateCallback(SourceControlCallback cb)
{
	fCallback = cb;
}


SourceControlCallback
SourceControl::GetUpdateCallback(void) const
{
	return fCallback;
}


void
SourceControl::RunCustomCommand(const char *command)
{
	BString cmd;
	// entire command must be generated by caller due to passing
	//   env variables (E.g. git to prevent login)
	cmd << /*GetShortName() << " " <<*/ command;
	BString out;
	RunCommand(cmd, out);
}


void
SourceControl::SetShortName(const char *name)
{
	fShortName = name;
}


void
SourceControl::SetLongName(const char *name)
{
	fLongName = name;
}


void
SourceControl::SetFlags(int32 flags)
{
	fFlags = flags;
}


BString
SourceControl::GetUsername(void) const
{
	return fUsername;
}


BString	
SourceControl::GetPassword(void) const
{
	return fPassword;
}


int
SourceControl::RunCommand(BString in, BString &out)
{
	if (fDebug)
		STRACE(2,("Command: %s: %s\n", fShortName.String(), in.String()));
	
	if (in.CountChars() < 1)
		return -1;
	
	//in << "\necho \"Source control command return value: $?\"";
	/*
	FILE *fd = popen(in.String(),"r");
	
	if (!fd)
		return -2;
	*/
	
	out = "";
	
	/*
	char buffer[1024];
	while (fgets(buffer,1024,fd))
	{
		if (!ferror(fd)) {
			if (fCallback)
				fCallback(buffer);
			out += buffer;
		} else {
			STRACE(2,("Command response buffer in error for SCM command"));
		}
	}
	
	int result = pclose(fd);
	*/
	BString cmd(in);
	//cmd << "sh -c \"" << in << "\"";
	STRACE(2,("SourceControl::RunCommand:Command: %s\n",cmd.String()));
	status_t retval = RunPipedCommand(cmd.String(),out,true);
	STRACE(2,("Command complete\n"));
	int result = 0;
	if (B_OK != retval) 
		result = -1;
	
	if (fDebug)
		STRACE(1,("%s: out:\n------------\n%s------------\n",
				GetShortName(), out.String()));
	
	// Grab the return value of the command
	//int32 pos = out.FindLast("Source control command return value");
	
	//int returnValue = atoi(out.String() + pos + strlen("Source control command return value: "));
	//out.Truncate(pos);
	out << "----------\n";
	if (-1 == result) {
		out << B_TRANSLATE("Command resulted in an error.\n");
	} else {
		out << 	B_TRANSLATE("Command succeeded. Use 'Import existing Project' "
				"function in the main window "
				"to load the project from the local filesystem\n");
	}
	out << "----------\n";
	
	if (fCallback)
		fCallback(out);
	
	return result;
}

