--[[ This is a lua script which holds the data to create the code for the
	PButton class with the PObGen script.
	
	The PObGen script expects the data to be defined into the PObject and
	PBackend tables. A few globals are also defined and this is normally
	done at the top of the file. The file itself can be divided into four
	main sections: globals, basic PObject definitions, PObject properties,
	PObject methods, and the backend definitions
]]

HeaderName = "PButton.h"
CodeFileName = "PButton.cpp"

ParentHeaderName = [["PControl.h"]]

Includes = { "<Application.h>", "<Button.h>", "<stdio.h>", }

PObject = {}

PObject.name = "PButton"
PObject.description = "A button"

-- This is for graphical controls which inherit PView somehow. It's
-- to make sure that the backend is handled as a BView derivative
PObject.usesView = true
PObject.friendlyName = "Button"
PObject.parentClass = "PControl"
PObject.parentAccess = "public"

-- This is the code expected to go into the PObject::InitBackend method
PObject.initBackend = [[
	if (!fView)
		fView = new PButtonBackend(this);
	
	// For buttons, seeing the value is senseless in an editor
	PProperty *prop = FindProperty("Value");
	SetFlagsForProperty(prop, PROPERTY_HIDE_IN_EDITOR);
]]

--[[-----------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
	The properties table contains a bunch of stuff.
	Each entry starts with the property name and type. The third item
	in the entry is a table containing the backend function and input type.
	The fourth item is the description string for the property, which must
	exist, but can be empty. The fifth item is a string containing the value
	to which the property is initialized. C++ code can be embedded in this string, and
	as such, strings need to be double quoted to ensure that one set makes it
	into the generated code.
	
	Sample "standard" property:
	{ "BarThickness", "float" , { "BarThickness", "void"}, { "SetBarThickness", "float" }, "", "6.0" },
	
	Sample enumerated property:
	{ "Orientation", "enum", { "Orientation", "void" }, { "SetOrientation", "(orientation)" }, "", "B_HORIZONTAL",
		{ pair("Horizontal", "B_HORIZONTAL"), pair("Vertical", "B_VERTICAL") } },
	
	Sample embedded property:
	{ "MaxLimit", "float", { "GetLimits", "embedded" }, { "SetLimits", "embedded" }, "", "100.0" },
	. . .

	PObject.embeddedProperties["MaxLimit"] = {}
	PObject.embeddedProperties["MaxLimit"].getCode = [=[
			int32 min, max;
			fSlider->GetLimits(&min, &max);
			((IntProperty*)prop)->SetValue(max);
	]=]
	PObject.embeddedProperties["MaxLimit"].setCode = [=[
			int32 min, max;
			fBackend->GetLimits(&min, &max);
		
			prop->GetValue(&intval);
			fBackend->SetLimits(*intval.value, max);
	]=]
]]

-- The button class doesn't add any new properties over what is inherited from PControl

-- We do add some inherited methods, however
PObject.inheritedMethods = {
	
}

------------------------------------------------------------------------------
-- Backend definitions

PBackend = {}
PBackend.name = "PButtonBackend"
PBackend.parent = "BButton"
PBackend.access = "public"
PBackend.init = [[BRect(0, 0, 1, 1), "", "", new BMessage]]
PBackend.eventHooks =
{
	{ "void", "AttachedToWindow", "void" },
	{ "void", "DetachedFromWindow", "void" },
	{ "void", "AllAttached", "void" },
	{ "void", "AllDetached", "void" },
	{ "void", "Pulse", "void" },
	{ "void", "MakeFocus", { pair("bool", "focus") } },
	{ "void", "FrameMoved", { pair("BPoint", "where") } },
	{ "void", "FrameResized", { pair("float", "width"), pair("float", "height") } },
	{ "void", "MouseDown", { pair("BPoint", "where") } },
	{ "void", "MouseUp", { pair("BPoint", "where") } },
	{ "void", "MouseMoved", { pair("BPoint", "where"), pair("uint32", "transit"), pair("const BMessage *", "message") } },
	{ "void", "WindowActivated", { pair("bool", "active") } },
	{ "void", "Draw", { pair("BRect", "update") } },
	{ "void", "DrawAfterChildren", { pair("BRect", "update") } },
	
	-- MessageReceived is automatically generated by the script
}

-- These are event hooks which require embedded code. Placeholders are honored here.
-- The entire function is defined -- no parameters are generated. Substitution is
-- performed on the placeholders and the code is entered into the file
PBackend.embeddedHooks = {}
PBackend.embeddedHooks[1] = {}
PBackend.embeddedHooks[1].definition = "\tvoid\tKeyDown(const char *bytes, int32 count);\n"
PBackend.embeddedHooks[1].code = [[
void
%(BACKENDNAME)::KeyDown(const char *bytes, int32 count)
{
	PArgs in, out;
	in.AddItem("bytes", (void*)bytes, count, PARG_RAW);
	in.AddInt32("count", count);
	EventData *data = fOwner->FindEvent("KeyDown");
	if (data->hook)
		fOwner->RunEvent(data, in.ListRef(), out.ListRef());
	else
		%(BACKEND_PARENT_NAME)::KeyDown(bytes, count);
}


]]

PBackend.embeddedHooks[2] = {}
PBackend.embeddedHooks[2].definition = "\tvoid\tKeyUp(const char *bytes, int32 count);\n"
PBackend.embeddedHooks[2].code = [[
void
%(BACKENDNAME)::KeyUp(const char *bytes, int32 count)
{
	PArgs in, out;
	in.AddItem("bytes", (void*)bytes, count, PARG_RAW);
	in.AddInt32("count", count);
	EventData *data = fOwner->FindEvent("KeyUp");
	if (data->hook)
		fOwner->RunEvent(data, in.ListRef(), out.ListRef());
	else
		%(BACKEND_PARENT_NAME)::KeyUp(bytes, count);
}


]]

